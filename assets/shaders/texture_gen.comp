#version 430 core
layout (local_size_x = 16, local_size_y = 16) in;
layout (rgba8, binding = 0) uniform image2D imgOutput;

uniform int mode; // 0: Noise (2D), 1: Planet (Spherical), 2: Sun (Spherical), 3: Glow Sprite
uniform int width;
uniform int height;
uniform float scale;
uniform int octaves;
uniform float persistence;
uniform int seed;

// Planet specific
uniform float waterLevel;
uniform vec3 color1;
uniform vec3 color2;

// GLSL Value Noise implementation
float hash(float n) {
    return fract(sin(n) * 43758.5453123);
}

float noise(vec3 x) {
    vec3 p = floor(x);
    vec3 f = fract(x);
    f = f * f * (3.0 - 2.0 * f);
    float n = p.x + p.y * 57.0 + 113.0 * p.z;
    return mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),
                   mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),
               mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
                   mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);
}

// Pseudo-random hash from CPU code ported to GLSL for consistency (optional, but standard GLSL hash above is usually fine)
// Using a better hash for 3D coordinates
float hash3(vec3 p) {
    p = fract(p * 0.3183099 + .1);
    p *= 17.0;
    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
}

float valueNoise(vec3 p, int s) {
    vec3 i = floor(p);
    vec3 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);

    // Offset seed
    float n = float(s);

    // Hash function that takes seed into account
    // We use a simple permutation polynomial or just mix the seed into the coordinate
    // For simplicity, let's use the standard noise with offset p

    // Standard value noise logic
    // We need to implement the exact same hash as CPU if we want exact results,
    // but for procedural textures, "good looking" is enough.
    // Let's use a robust GLSL noise.

    return noise(p + vec3(s * 13.0));
}

float octaveNoise(vec3 p, int octs, float pers, int s) {
    float total = 0.0;
    float frequency = 1.0;
    float amplitude = 1.0;
    float maxValue = 0.0;

    for(int i = 0; i < octs; i++) {
        total += valueNoise(p * frequency, s) * amplitude;
        maxValue += amplitude;
        amplitude *= pers;
        frequency *= 2.0;
    }

    return total / maxValue;
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    if(texelCoord.x >= width || texelCoord.y >= height) return;

    float nx = float(texelCoord.x) / float(width);
    float ny = float(texelCoord.y) / float(height);
    vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0);

    if (mode == 0) { // Noise Texture (2D, seamless)
        float dx = cos(nx * 2.0 * 3.14159);
        float dz = sin(nx * 2.0 * 3.14159);
        float dy = ny * 2.0 - 1.0;

        float n = octaveNoise(vec3(dx, dy, dz) * scale, octaves, persistence, seed);
        pixel = vec4(vec3(n), 1.0);
    }
    else if (mode == 1) { // Planet
        float angle = nx * 2.0 * 3.14159;
        float heightVal = ny * 2.0 - 1.0;
        float radius = sqrt(max(0.0, 1.0 - heightVal * heightVal));

        float dx = radius * cos(angle);
        float dz = radius * sin(angle);
        float dy = heightVal;

        float n = octaveNoise(vec3(dx, dy, dz) * scale, 6, 0.5, seed);
        float detail = octaveNoise(vec3(dx, dy, dz) * scale * 5.0, 3, 0.5, seed + 100);
        n += detail * 0.1;

        if (n < waterLevel) {
            float deep = n / waterLevel;
            pixel = vec4(0.0, 0.2 * deep + 0.08, 0.6 * deep + 0.2, 1.0);
        } else {
            float land = (n - waterLevel) / (1.0 - waterLevel);
            pixel = vec4(mix(color1, color2, land), 1.0);
        }
    }
    else if (mode == 2) { // Sun
        float angle = nx * 2.0 * 3.14159;
        float heightVal = ny * 2.0 - 1.0;
        float radius = sqrt(max(0.0, 1.0 - heightVal * heightVal));

        float dx = radius * cos(angle);
        float dz = radius * sin(angle);
        float dy = heightVal;

        float n = octaveNoise(vec3(dx, dy, dz) * scale, 8, 0.6, seed);

        float r, g, b;
        if (n > 0.7) {
            float t = (n - 0.7) / 0.3;
            r = 1.0; g = 1.0; b = t;
        } else if (n > 0.4) {
            float t = (n - 0.4) / 0.3;
            r = 1.0; g = 0.5 + 0.5 * t; b = 0.0;
        } else {
            float t = n / 0.4;
            r = 0.8 + 0.2 * t; g = 0.2 * t; b = 0.0;
        }
        pixel = vec4(r, g, b, 1.0);
    }
    else if (mode == 3) { // Glow Sprite
        float dx = nx * 2.0 - 1.0;
        float dy = ny * 2.0 - 1.0;
        float distSq = dx*dx + dy*dy;

        // Soft Gaussian glow
        float alpha = exp(-distSq * 4.0);

        // Harder core
        float core = exp(-distSq * 16.0);

        float finalAlpha = alpha;

        // White core, slight tint on edge handled by vertex color usually
        pixel = vec4(1.0, 1.0, 1.0, finalAlpha);
    }

    imageStore(imgOutput, texelCoord, pixel);
}
