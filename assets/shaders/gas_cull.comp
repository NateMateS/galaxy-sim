#version 430 core
#extension GL_KHR_shader_subgroup_ballot : require
layout(local_size_x = 256) in;

// Packed Input (24 bytes)
struct GasInput {
    float orbitalRadius;       // 4 bytes
    uint packedOrbital;        // 4 bytes (angle, velocity) - Half2x16
    uint packedOffsetsXY;      // 4 bytes (x, y) - Half2x16
    uint packedOffsetZSize;    // 4 bytes (z, size) - Half2x16
    uint color;                // 4 bytes (rgba8)
    uint packedTurbulence;     // 4 bytes (phase, speed) - Half2x16
};

// Packed Output (20 bytes)
struct GasRender {
    float px, py, pz;    // 12 bytes (Split vec3 to avoid std430 16-byte alignment)
    uint color;          // 4 bytes
    float size;          // 4 bytes
};

struct DrawCommand {
    uint count;
    uint instanceCount;
    uint first;
    uint baseInstance;
};

layout(std430, binding = 0) readonly buffer InputBuffer {
    GasInput particles[];
};

layout(std430, binding = 1) writeonly buffer OutputBuffer {
    GasRender visibleParticles[];
};

layout(std430, binding = 2) buffer IndirectBuffer {
    DrawCommand cmd;
};

layout(std140, binding = 0) uniform GlobalUniforms {
    mat4 view;
    mat4 projection;
    vec4 viewPosTime;
};

uniform float pointScale;
uniform sampler2D depthMap;
uniform float screenWidth;
uniform float screenHeight;
uniform float zNear;
uniform float zFar;

float LinearizeDepth(float depth) {
    float z = depth * 2.0 - 1.0;
    return (2.0 * zNear * zFar) / (zFar + zNear - z * (zFar - zNear));
}

bool isVisible(vec3 viewPos, float radius) {
    vec4 clipPos = projection * vec4(viewPos, 1.0);
    vec3 ndc = clipPos.xyz / clipPos.w;

    // Check if in front of camera and roughly within screen bounds
    return clipPos.w > 0.0 && all(lessThan(abs(ndc), vec3(1.3))); // Generous margin for large particles
}

void main() {
    float time = viewPosTime.w;
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= particles.length()) return;

    GasInput p = particles[idx];

    // --- Unpack Data ---
    float orbitalRadius = p.orbitalRadius;
    vec2 orbitalParams = unpackHalf2x16(p.packedOrbital);
    float initialAngle = orbitalParams.x;
    float angularVelocity = orbitalParams.y / 1000.0; // Unscale velocity

    vec2 offsetsXY = unpackHalf2x16(p.packedOffsetsXY);
    vec2 offsetZSize = unpackHalf2x16(p.packedOffsetZSize);
    vec3 offset = vec3(offsetsXY.x, offsetsXY.y, offsetZSize.x);
    float size = offsetZSize.y;

    vec2 turbulenceParams = unpackHalf2x16(p.packedTurbulence);
    float turbPhase = turbulenceParams.x;
    float turbSpeed = turbulenceParams.y;

    // --- Physics Simulation ---
    // 1. Orbital Angle
    float currentAngle = initialAngle + angularVelocity * time;
    float cosA = cos(currentAngle);
    float sinA = sin(currentAngle);

    vec3 cloudCenter = vec3(orbitalRadius * cosA, 0.0, orbitalRadius * sinA);

    // 2. Rotate Local Offset
    float localX = offset.x * cosA - offset.z * sinA;
    float localZ = offset.x * sinA + offset.z * cosA;
    vec3 rotatedOffset = vec3(localX, offset.y, localZ);

    // 3. Turbulence
    float turbulence = sin(time * turbSpeed + turbPhase);
    vec3 turbOffset = vec3(0.0, turbulence * 2.0, 0.0);

    // 4. World Position
    vec3 worldPos = cloudCenter + rotatedOffset + turbOffset;

    // 5. View Position
    vec4 viewPosVec = view * vec4(worldPos, 1.0);
    vec3 viewPos = viewPosVec.xyz;

    // --- Frustum Culling ---
    if (!isVisible(viewPos, size)) return;

    // --- Render Prep ---
    float dist = length(viewPos);
    if (dist < 0.1) dist = 0.1;

    // --- Stochastic LOD ---
    float baseSize = size;
    float scale = (pointScale < 1.0) ? 200.0 : pointScale;
    float projectedSize = scale * baseSize * (1.0 / dist);

    // Calculate survival probability based on screen area
    // Smaller particles are less likely to survive, but get brighter
    float area = projectedSize * projectedSize;
    // This aggressively reduces the number of small distant particles processed.
    float keepProbability = clamp(area / 64.0, 0.0, 1.0);

    // Pseudo-random hash for stable stochastic culling
    uint hash = idx * 747796405u + 2891336453u;
    hash = ((hash >> 16) ^ hash) * 277803737u;
    float randVal = float(hash) / 4294967295.0;

    if (randVal > keepProbability) return;

    // --- Occlusion Culling ---
    vec4 clipPos = projection * vec4(viewPos, 1.0);
    vec3 ndc = clipPos.xyz / clipPos.w;
    vec2 screenUV = ndc.xy * 0.5 + 0.5;
    ivec2 screenCoords = ivec2(screenUV * vec2(screenWidth, screenHeight));

    if (screenCoords.x >= 0 && screenCoords.x < int(screenWidth) &&
        screenCoords.y >= 0 && screenCoords.y < int(screenHeight)) {

        float depthNonLinear = texelFetch(depthMap, screenCoords, 0).r;
        float depthLinear = LinearizeDepth(depthNonLinear);
        float particleDist = -viewPos.z;

        // Cull if particle is significantly behind geometry (allow 20.0 units margin)
        if (particleDist > depthLinear + 20.0) return;
    }

    // --- Render Prep ---
    float finalSize = clamp(projectedSize, 1.0, 128.0);

    // Alpha Fade near camera
    float alphaFade = smoothstep(1.0, 50.0, dist);

    // Unpack Color
    vec4 unpackedColor = unpackUnorm4x8(p.color);

    // Apply stochastic compensation and camera fade
    unpackedColor.a *= alphaFade * (1.0 / max(keepProbability, 0.001));

    if (unpackedColor.a < 0.001) return;

    // Repack color for output (optional, but we use uint in struct)
    uint finalColorPacked = packUnorm4x8(unpackedColor);

    // --- Output Aggregation ---
    uvec4 ballot = subgroupBallot(true);
    uint count = subgroupBallotBitCount(ballot);
    uint baseIndex = 0;

    if (subgroupElect()) {
        baseIndex = atomicAdd(cmd.count, count);
    }
    baseIndex = subgroupBroadcastFirst(baseIndex);
    uint localOffset = subgroupBallotExclusiveBitCount(ballot);
    uint outIdx = baseIndex + localOffset;

    visibleParticles[outIdx].px = viewPos.x;
    visibleParticles[outIdx].py = viewPos.y;
    visibleParticles[outIdx].pz = viewPos.z;
    visibleParticles[outIdx].color = finalColorPacked;
    visibleParticles[outIdx].size = finalSize;
}
