#version 430 core
#extension GL_KHR_shader_subgroup_ballot : require
layout(local_size_x = 256) in;

struct StarInput {
    vec4 orbit;  // x: radius, y: initialAngle, z: y_pos, w: angularVelocity
    vec4 color;  // x: r, y: g, z: b, w: brightness
};

struct StarRender {
    vec4 position_doppler; // xyz: position, w: doppler_shift
    vec4 color_size;       // xyz: color, w: size/brightness
};

struct DrawCommand {
    uint count;
    uint instanceCount;
    uint first;
    uint baseInstance;
};

layout(std430, binding = 0) readonly buffer InputBuffer {
    StarInput stars[];
};

layout(std430, binding = 1) writeonly buffer OutputBuffer {
    StarRender visibleStars[];
};

layout(std430, binding = 2) buffer IndirectBuffer {
    DrawCommand cmd;
};

layout(std140, binding = 0) uniform GlobalUniforms {
    mat4 view;
    mat4 projection;
    vec4 viewPos;
    float time;
};

uniform float screenHeight;
uniform float bulgeRadius;

bool isVisible(vec3 pos, float radius) {
    vec4 clipPos = projection * view * vec4(pos, 1.0);
    vec3 ndc = clipPos.xyz / clipPos.w;

    // Check if in front of camera (clipPos.w > 0) and within NDC bounds
    // Add a margin (1.1 instead of 1.0) for the point size
    return clipPos.w > 0.0 &&
           all(lessThan(abs(ndc), vec3(1.2)));
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= stars.length()) return;

    StarInput inStar = stars[idx];

    // 1. Orbital Physics
    float radius = inStar.orbit.x;
    float currentAngle = inStar.orbit.y + inStar.orbit.w * time;
    float y = inStar.orbit.z;

    float cosA = cos(currentAngle);
    float sinA = sin(currentAngle);

    vec3 pos = vec3(radius * cosA, y, radius * sinA);

    // 2. Frustum Culling
    // Simple point culling
    if (!isVisible(pos, 0.0)) return;

    // 3. Doppler Calculation
    // Velocity vector direction is (-sin, 0, cos)
    vec3 orbitVel = vec3(-sinA, 0.0, cosA) * radius * inStar.orbit.w;
    vec3 viewVel = vec3(view * vec4(orbitVel, 0.0));
    float radialSpeed = viewVel.z;
    float shift = clamp(radialSpeed * 0.1, -0.9, 0.9);

    // 4. Color Processing
    vec3 baseColor = inStar.color.rgb;
    vec3 dopplerColor = baseColor * vec3(1.0 - shift, 1.0 - abs(shift) * 0.2, 1.0 + shift);

    // 5. Brightness & Size
    // Calculate view space depth for size attenuation
    vec4 viewPosVec = view * vec4(pos, 1.0);
    float dist = length(viewPosVec.xyz);
    if(dist < 0.1) dist = 0.1;

    float attenuation = 1.0 / (1.0 + 0.0001 * dist + 0.000005 * dist * dist);
    float brightness = inStar.color.w * attenuation;
    float mappedBrightness = sqrt(brightness);

    // 6. Write to Output (Subgroup Optimized)
    uvec4 ballot = subgroupBallot(true);
    uint count = subgroupBallotBitCount(ballot);
    uint baseIndex = 0;

    // First active thread reserves space for the whole subgroup
    if (subgroupElect()) {
        baseIndex = atomicAdd(cmd.count, count);
    }

    // Broadcast base index to all active threads
    baseIndex = subgroupBroadcastFirst(baseIndex);

    // Calculate local offset within the subgroup
    uint localOffset = subgroupBallotExclusiveBitCount(ballot);

    uint outIdx = baseIndex + localOffset;

    visibleStars[outIdx].position_doppler = vec4(pos, shift);
    visibleStars[outIdx].color_size = vec4(dopplerColor, mappedBrightness);
}
