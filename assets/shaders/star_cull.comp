#version 430 core
#extension GL_KHR_shader_subgroup_ballot : require
layout(local_size_x = 256) in;

// Packed Input (16 bytes)
struct StarInput {
    float radius;            // 4
    uint packedOrbital;      // 4 (angle, velocity)
    uint packedYBright;      // 4 (y, brightness)
    uint color;              // 4 (rgba8)
};

// Packed Output (20 bytes)
struct StarRender {
    float px, py, pz; // 12
    uint color;       // 4
    float size;       // 4
};

struct DrawCommand {
    uint count;
    uint instanceCount;
    uint first;
    uint baseInstance;
};

layout(std430, binding = 0) readonly buffer InputBuffer {
    StarInput stars[];
};

layout(std430, binding = 1) writeonly buffer OutputBuffer {
    StarRender visibleStars[];
};

layout(std430, binding = 2) buffer IndirectBuffer {
    DrawCommand cmd;
};

layout(std140, binding = 0) uniform GlobalUniforms {
    mat4 view;
    mat4 projection;
    vec4 viewPosTime;
};

uniform float screenHeight;
uniform float bulgeRadius;

bool isVisible(vec3 pos, float radius) {
    vec4 clipPos = projection * view * vec4(pos, 1.0);
    vec3 ndc = clipPos.xyz / clipPos.w;

    // Check if in front of camera (clipPos.w > 0) and within NDC bounds
    // Add a margin (1.1 instead of 1.0) for the point size
    return clipPos.w > 0.0 &&
           all(lessThan(abs(ndc), vec3(1.2)));
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= stars.length()) return;

    StarInput inStar = stars[idx];

    // --- Unpack ---
    float radius = inStar.radius;
    vec2 orbital = unpackHalf2x16(inStar.packedOrbital);
    float initialAngle = orbital.x;
    float velocity = orbital.y / 1000.0; // Unscale velocity

    vec2 yBright = unpackHalf2x16(inStar.packedYBright);
    float y = yBright.x;
    float rawBrightness = yBright.y;

    vec4 unpackedColor = unpackUnorm4x8(inStar.color);
    vec3 baseColor = unpackedColor.rgb;

    float time = viewPosTime.w;

    // 1. Orbital Physics
    float currentAngle = initialAngle + velocity * time;

    float cosA = cos(currentAngle);
    float sinA = sin(currentAngle);

    vec3 pos = vec3(radius * cosA, y, radius * sinA);

    // 2. Frustum Culling
    if (!isVisible(pos, 0.0)) return;

    // 3. Doppler Calculation
    // Velocity vector direction is (-sin, 0, cos)
    vec3 orbitVel = vec3(-sinA, 0.0, cosA) * radius * velocity;
    vec3 viewVel = vec3(view * vec4(orbitVel, 0.0));
    float radialSpeed = viewVel.z;
    float shift = clamp(radialSpeed * 0.1, -0.9, 0.9);

    // 4. Color Processing
    vec3 dopplerColor = baseColor * vec3(1.0 - shift, 1.0 - abs(shift) * 0.2, 1.0 + shift);
    // Clamp color to 0..1 for packing
    dopplerColor = clamp(dopplerColor, 0.0, 1.0);

    // 5. Brightness & Size
    vec4 viewPosVec = view * vec4(pos, 1.0);
    float dist = length(viewPosVec.xyz);
    if(dist < 0.1) dist = 0.1;

    float attenuation = 1.0 / (1.0 + 0.0001 * dist + 0.000005 * dist * dist);
    float brightness = rawBrightness * attenuation;
    float mappedBrightness = sqrt(brightness);

    // Repack color (include brightness in alpha? No, size/brightness is separate float)
    // Wait, vertex shader needs color and brightness.
    // Previously: aColorSize (color, brightness).
    // New: color (uint), size (float).
    // I should pack color into uint.
    // What about brightness?
    // mappedBrightness is passed as "size" or "brightness" to vertex shader.
    // Vertex shader uses it for size calculation AND alpha.
    // "StarRender.size" = mappedBrightness.

    uint packedDopplerColor = packUnorm4x8(vec4(dopplerColor, 1.0));

    // 6. Write to Output (Subgroup Optimized)
    uvec4 ballot = subgroupBallot(true);
    uint count = subgroupBallotBitCount(ballot);
    uint baseIndex = 0;

    // First active thread reserves space for the whole subgroup
    if (subgroupElect()) {
        baseIndex = atomicAdd(cmd.count, count);
    }

    // Broadcast base index to all active threads
    baseIndex = subgroupBroadcastFirst(baseIndex);

    // Calculate local offset within the subgroup
    uint localOffset = subgroupBallotExclusiveBitCount(ballot);

    uint outIdx = baseIndex + localOffset;

    visibleStars[outIdx].px = pos.x;
    visibleStars[outIdx].py = pos.y;
    visibleStars[outIdx].pz = pos.z;
    visibleStars[outIdx].color = packedDopplerColor;
    visibleStars[outIdx].size = mappedBrightness;
}
